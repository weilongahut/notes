#Java 编程思想#
----
##为什么需要内部类##
<br>

每个内部类都可以独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部了都是没有影响的，所以内部类可以实现多重继承。

<Strong>内部类是不可以像方法一样被覆盖的，但是可以被明确地继承 </Strong>

<Strong>局部内部类和匿名类：使用一个局部内部类的理由在于需要一个已命名的构造器，或者需要重载构造器，而<em>匿名内部类只能用于实例化，</em>
另外一种情况，当需要多个该内部类的对象时，使用局部内部类</Strong>

##Java的Iterator##
Iterator只能单向移动，这个Iterator只能用来

- 使用iterator()要求容器返回一个Iterator对象，Iterator将准备好返回序列的第一个元素
- 使用next()方法获取序列的下一个元素
- 使用hasNext()方法检查序列中是否还有元素
- 使用remove()将迭代器新近返回的元素删除

使用接口描述的一个理由是她可以让我们能够创建更通用的代码，通过针对接口而不是具体实现来编写代码，我们的代码可以应用于更多的对象类型。实现Collection接口就意味着必须使用Iterator，即提供iterator()方法

##Java异常处理##
异常处理的一个重要原则是：只捕获自己知道如何处理的异常！

异常处理理论上有两种模型：终止模型和回复模型。

- 终止模型假设异常非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。
- 恢复模型，意识是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。

<Strong>RuntimeException可以在没有异常说明的情况下被抛出
重新抛出异常会把异常抛给上一级环境中的异常处理程序，同一个try块的后续catch子句将被忽略
</Strong>

Throwable有两个子类：Error和Exception，Error用来表示编译时和系统错误，除特殊情况外，一般不需要程序员关心，Exception是可以被抛出的基本类型

<Strong> 从finally子句中return会导致异常丢失</Strong>



